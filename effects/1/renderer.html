<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Lottie Renderer</title>
    <style>
      html, body {
        margin: 0; padding: 0; background: transparent; overflow: hidden;
        width: 100%; height: 100%;
      }
      #container {
        position: absolute; left: 0; top: 0; background: transparent;
      }
      canvas { background: transparent !important; }
    </style>
    <script src="https://unpkg.com/lottie-web/build/player/lottie.min.js"></script>
  </head>
  <body>
    <div id="container"></div>
    <script>
      const query = new URLSearchParams(location.search);
      const width  = parseInt(query.get('width')  || '512', 10);
      const height = parseInt(query.get('height') || '512', 10);
      const scale  = parseFloat(query.get('scale') || '1');
      const lottieUrl = query.get('lottie');
      const textOverride = query.get('textOverride');
      // Text mode params
      const text = query.get('text');
      const font = (query.get('font') || 'Arial').trim();
      const fontSize = parseInt(query.get('fontSize') || '72', 10);
      const color = (query.get('color') || '#ffffff').trim();
      const effect = (query.get('effect') || 'fade').trim(); // fade | typewriter | slide
      const fpsParam = query.get('fps');
      const durationParam = query.get('duration');
      const fpsText = fpsParam ? parseInt(fpsParam, 10) : 30;
      const durationText = durationParam ? parseFloat(durationParam) : 3.0;

      // Resize container to desired overlay size
      const container = document.getElementById('container');
      container.style.width = width + 'px';
      container.style.height = height + 'px';

      let anim = null;
      let readyResolve;
      const ready = new Promise(r => readyResolve = r);

      async function loadLottie(data) {
        if (anim) { anim.destroy(); anim = null; }
        anim = lottie.loadAnimation({
          container,
          renderer: 'canvas',      // uses 2D canvas with alpha
          loop: false,
          autoplay: false,
          animationData: data
        });
        anim.addEventListener('DOMLoaded', () => {
          // Apply scale by CSS transform to the canvas container
          if (scale !== 1) {
            container.style.transformOrigin = 'top left';
            container.style.transform = `scale(${scale})`;
          }
          readyResolve();
        });
      }

      async function fetchJson(u) {
        const res = await fetch(u);
        if (!res.ok) throw new Error(`Failed to fetch Lottie: ${res.status}`);
        return res.json();
      }

      function applyTextOverride(data, newText) {
        if (!data) return;
        const overrideLayers = (layers) => {
          if (!layers || !Array.isArray(layers)) return;
          for (const layer of layers) {
            // Text layers in Lottie typically have ty === 5
            if (layer && layer.ty === 5 && layer.t && layer.t.d && Array.isArray(layer.t.d.k)) {
              for (const k of layer.t.d.k) {
                if (k && k.s && typeof k.s.t === 'string') {
                  k.s.t = newText;
                }
              }
            }
          }
        };

        // Override top-level layers
        overrideLayers(data.layers);
        // Override nested precomp layers in assets
        if (Array.isArray(data.assets)) {
          for (const asset of data.assets) {
            if (asset && Array.isArray(asset.layers)) {
              overrideLayers(asset.layers);
            }
          }
        }
      }

      // --- Text Mode Implementation ---
      // If text is provided, we draw on our own canvas instead of lottie-web
      let textCanvas = null;
      let textCtx = null;
      let textTotalFrames = Math.max(1, Math.round(durationText * fpsText));

      function ensureTextCanvas() {
        if (textCanvas) return;
        textCanvas = document.createElement('canvas');
        textCanvas.width = width;
        textCanvas.height = height;
        textCanvas.style.width = width + 'px';
        textCanvas.style.height = height + 'px';
        container.appendChild(textCanvas);
        textCtx = textCanvas.getContext('2d');
        if (scale !== 1) {
          container.style.transformOrigin = 'top left';
          container.style.transform = `scale(${scale})`;
        }
      }

      function clearCanvas() {
        textCtx.clearRect(0, 0, width, height);
      }

      function drawCenteredText(str, alpha = 1.0, revealChars = null, offsetX = 0) {
        textCtx.save();
        textCtx.globalAlpha = alpha;
        textCtx.fillStyle = color;
        textCtx.textAlign = 'center';
        textCtx.textBaseline = 'middle';
        textCtx.font = `${fontSize}px ${font}`;

        const x = Math.floor(width / 2) + offsetX;
        const y = Math.floor(height / 2);

        const toRender = revealChars == null ? str : str.slice(0, Math.max(0, Math.min(str.length, revealChars)));
        textCtx.fillText(toRender, x, y);
        textCtx.restore();
      }

      function renderTextFrame(frameNumber) {
        const progress = Math.min(1, Math.max(0, frameNumber / (textTotalFrames - 1)));
        clearCanvas();
        if (effect === 'fade') {
          const alpha = progress;
          drawCenteredText(text, alpha, null, 0);
        } else if (effect === 'typewriter') {
          const chars = Math.round(text.length * progress);
          drawCenteredText(text, 1.0, chars, 0);
        } else if (effect === 'slide') {
          const startXOff = -Math.floor(width * 0.5);
          const endXOff = 0;
          const off = Math.round(startXOff + (endXOff - startXOff) * progress);
          drawCenteredText(text, 1.0, null, off);
        } else {
          // default to fade
          const alpha = progress;
          drawCenteredText(text, alpha, null, 0);
        }
        return textCanvas.toDataURL('image/png');
      }

      // Expose control functions to Node via puppeteer
      window.__lottieReady = async function() {
        if (text) {
          ensureTextCanvas();
          readyResolve();
        } else if (lottieUrl) {
          const data = await fetchJson(lottieUrl);
          if (textOverride) {
            applyTextOverride(data, textOverride);
          }
          await loadLottie(data);
        }
        return ready;
      };

      window.__loadAnimation = async function(jsonStr) {
        const data = JSON.parse(jsonStr);
        await loadLottie(data);
        return ready;
      };

      window.__getMeta = function() {
        if (text) {
          return { fr: fpsText, totalFrames: textTotalFrames, duration: durationText, width, height, scale };
        }
        if (!anim) return null;
        const fr = anim.frameRate;       // frames per second in the Lottie file
        const totalFrames = Math.floor(anim.getDuration(true));
        const duration = anim.getDuration(false); // seconds
        return { fr, totalFrames, duration, width, height, scale };
      };

      window.__renderFrame = async function(frameNumber) {
        if (text) {
          return renderTextFrame(frameNumber);
        }
        if (!anim) throw new Error('Animation not loaded');
        anim.goToAndStop(frameNumber, true);
        // Find the canvas element created by lottie-web
        const canvas = container.querySelector('canvas');
        if (!canvas) throw new Error('Canvas not available yet');
        return canvas.toDataURL('image/png');
      };

      // Kick initial ready if URL param exists
      window.__lottieReady();
    </script>
  </body>
</html>
